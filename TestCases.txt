val k = AxiomR([], IMP(ATOM("x"), IMP(ATOM("y"), ATOM("x"))));
val s = AxiomR([], IMP( IMP( ATOM("x"), IMP(ATOM("y"), ATOM("z") ) ), IMP(IMP(ATOM("x"), ATOM("y")), IMP(ATOM("x"), ATOM("z") ) ) ) );
val n = AxiomR([], IMP( IMP(NOT(ATOM("y")), NOT(ATOM("x")) ) , IMP( IMP(NOT(ATOM("y")), ATOM("x") ), ATOM("y") ) ) );
val mp = BinaryInfR ( ([],ATOM("x") ),  ([], IMP(ATOM("x"), ATOM("y") ) ) , ([], ATOM("y") ) );
val r = AxiomR([], IMP(ATOM("x") , ATOM("x")))
val dt_back = UnaryInfR ( ([], IMP( ATOM("x"), ATOM("y") ) ) , ([ATOM("x")], ATOM("y") ) )
val dt_front = UnaryInfR ( ([ATOM("x")], ATOM("y") ), ([], IMP( ATOM("x"), ATOM("y") ) ) )
val t_front = BinaryInfR( ([], IMP( ATOM("x"), ATOM("y") ) )  , ([], IMP( ATOM("y"), ATOM("z") ) ) , ([], IMP( ATOM("x"), ATOM("z") ) ))
val z = isProofRuleListSound([k,s,n,mp,r,dt_back,dt_front,t_front]);

Part 2:

val x = IMP( IMP( ATOM("p"), ATOM("p")), IMP( ATOM("q"), IMP( ATOM("p"), ATOM("p") ) ) );
val r = IMP(ATOM("X"), IMP(ATOM("Y"), ATOM("X") ) );
val r2 = IMP(ATOM("X"), ATOM("X"))
val z = unifyProp(x,r2);

(* Example in Question *)
val k = AxiomR(([], IMP(ATOM("X"), IMP( ATOM("Y"), ATOM("X")))));
val r = AxiomR(([], IMP(ATOM("X"), ATOM("X"))));
val mp = BinaryInfR(([], ATOM("X")), ([], IMP(ATOM("X"), ATOM("Y"))), ([], ATOM("Y")) );
val proofrules = [k,r,mp];

val l1 = Axiom( ([], IMP( IMP( ATOM("p"), ATOM("p") ) , IMP(ATOM("q"), IMP( ATOM("p"), ATOM("p") ) ) ) ) );
val l2 = Axiom( ([], IMP (ATOM("p"), ATOM("p") ) ) );
val n1 = BinaryInf( (l1, l2, ([],IMP( ATOM("q"), IMP( ATOM("p"), ATOM("p") ) )) ) );

val it1 = isValidProofTree(n1, proofrules);

(* Transitivity *)
val X = ATOM("X");
val Y = ATOM("Y");
val Z = ATOM("Z");
val pr1 = BinaryInfR( ([],IMP(X,Y)), ([],IMP(Y,Z)), ([],IMP(X,Z)) );
val pr2 = AxiomR( ([], IMP(X,Y)) );
val a = ATOM("a");
val b = ATOM("b");
val c = ATOM("c");
val p = BinaryInf( Axiom( ([], IMP(b,c)) ), Axiom( ([], IMP(a,b)) ), ([], IMP(a,c)));

val it2 = isValidProofTree(p, [pr1,pr2]);

(* Contrapositive *)
val X = ATOM("X");
val Y = ATOM("Y");
val Z = ATOM("Z");
val K = AxiomR(([], IMP( X , IMP( Y, X) ) ) );
val N1 = IMP(NOT(Y), NOT(X));
val N2 = IMP( IMP(NOT(Y) , X) , Y);
val N = AxiomR( ([], IMP( N1 , N2 ) ) );
val S = AxiomR(([], IMP( IMP(X, IMP(Y,Z)) , IMP( IMP(X,Y), IMP(X,Z) ))));
val DT1 = UnaryInfR( (([], IMP(X,Y)) , ([X], Y) ) );
val DT2 = UnaryInfR( (([X], Y) , ([], IMP(X,Y) ) ) );
val T = BinaryInfR( ( ([], IMP(X,Y) ), ([], IMP(Y,Z)), ([], IMP(X,Z) ) ) );
val propRules = [K,N,S,DT1,DT2,T];

val p = ATOM("p");
val q = ATOM("q");
val L1 = Axiom( ([], IMP( IMP(NOT(q), NOT(p) ) , IMP( IMP(NOT(q), p ), q ) ) ) );
val L2 = Axiom( ([IMP(NOT(q), NOT(p))] , IMP (p, IMP(NOT(q), p) ) ) );
val N1 = UnaryInf( ( L1, ([IMP(NOT(q), NOT(p))] , IMP( IMP(NOT(q), p), q) ) ) );
val N2 = BinaryInf((N1, L2 , ([IMP(NOT(q), NOT(p))], IMP(p, q) ) ) );
val N2 = UnaryInf( ( N2, ([], IMP( IMP(NOT(q), NOT(p) ) , IMP(p,q) ) ) ) );

val it3 = isValidProofTree( N2, propRules);
